// Generated by Dogma Dart. DO NOT MODIFY!
// 2016-12-06 16:43:12.078728

library sense_model.src.convert.nx_inline_dimension_def_convert;

//---------------------------------------------------------------------
// Standard libraries
//---------------------------------------------------------------------

import 'dart:convert';

//---------------------------------------------------------------------
// Imports
//---------------------------------------------------------------------

import 'package:dogma_convert/convert.dart';
import 'package:sense_model/models.dart';
import 'nx_attr_expr_def_convert.dart';
import 'nx_field_attributes_convert.dart';
import 'nx_sort_criteria_convert.dart';

//---------------------------------------------------------------------
// Library contents
//---------------------------------------------------------------------

/// A [ModelDecoder] for [NxInlineDimensionDef].
class NxInlineDimensionDefDecoder extends Converter<Map, NxInlineDimensionDef>
    implements ModelDecoder<NxInlineDimensionDef> {
  final Converter<Map, NxSortCriteria> _nxSortCriteriaDecoder;
  final Converter<Map, NxFieldAttributes> _nxFieldAttributesDecoder;
  final Converter<Map, NxAttrExprDef> _nxAttrExprDefDecoder;
  NxInlineDimensionDefDecoder()
      : _nxSortCriteriaDecoder = new NxSortCriteriaDecoder(),
        _nxFieldAttributesDecoder = new NxFieldAttributesDecoder(),
        _nxAttrExprDefDecoder = new NxAttrExprDefDecoder();
  NxInlineDimensionDefDecoder.using(this._nxSortCriteriaDecoder,
      this._nxFieldAttributesDecoder, this._nxAttrExprDefDecoder);
  @override
  NxInlineDimensionDef create() => new NxInlineDimensionDef();
  @override
  NxInlineDimensionDef convert(Map input, [NxInlineDimensionDef model]) {
    model ??= create();

    model.qFieldDefs = input['qFieldDefs'];
    model.qFieldLabels = input['qFieldLabels'];
    model.qGrouping = input['qGrouping'];
    var qSortCriterias = input['qSortCriterias'];
    if (qSortCriterias != null) {
      var qSortCriteriasTemp0 = <NxSortCriteria>[];
      for (var qSortCriteriasValue0 in qSortCriterias) {
        qSortCriteriasTemp0
            .add(_nxSortCriteriaDecoder.convert(qSortCriteriasValue0));
      }
      model.qSortCriterias = qSortCriteriasTemp0;
    }
    var qNumberPresentations = input['qNumberPresentations'];
    if (qNumberPresentations != null) {
      var qNumberPresentationsTemp0 = <NxFieldAttributes>[];
      for (var qNumberPresentationsValue0 in qNumberPresentations) {
        qNumberPresentationsTemp0
            .add(_nxFieldAttributesDecoder.convert(qNumberPresentationsValue0));
      }
      model.qNumberPresentations = qNumberPresentationsTemp0;
    }
    model.qReverseSort = input['qReverseSort'];
    var qAttributeExpressions = input['qAttributeExpressions'];
    if (qAttributeExpressions != null) {
      var qAttributeExpressionsTemp0 = <NxAttrExprDef>[];
      for (var qAttributeExpressionsValue0 in qAttributeExpressions) {
        qAttributeExpressionsTemp0
            .add(_nxAttrExprDefDecoder.convert(qAttributeExpressionsValue0));
      }
      model.qAttributeExpressions = qAttributeExpressionsTemp0;
    }
    model.qActiveField = input['qActiveField'];
    return model;
  }
}

/// A [ModelEncoder] for [NxInlineDimensionDef].
class NxInlineDimensionDefEncoder extends Converter<NxInlineDimensionDef, Map>
    implements ModelEncoder<NxInlineDimensionDef> {
  final Converter<NxSortCriteria, Map> _nxSortCriteriaEncoder;
  final Converter<NxFieldAttributes, Map> _nxFieldAttributesEncoder;
  final Converter<NxAttrExprDef, Map> _nxAttrExprDefEncoder;
  NxInlineDimensionDefEncoder()
      : _nxSortCriteriaEncoder = new NxSortCriteriaEncoder(),
        _nxFieldAttributesEncoder = new NxFieldAttributesEncoder(),
        _nxAttrExprDefEncoder = new NxAttrExprDefEncoder();
  NxInlineDimensionDefEncoder.using(this._nxSortCriteriaEncoder,
      this._nxFieldAttributesEncoder, this._nxAttrExprDefEncoder);
  @override
  Map convert(NxInlineDimensionDef input) {
    var model = {};

    var qFieldDefs = input.qFieldDefs;
    if (qFieldDefs != null) {
      model['qFieldDefs'] = qFieldDefs;
    }
    var qFieldLabels = input.qFieldLabels;
    if (qFieldLabels != null) {
      model['qFieldLabels'] = qFieldLabels;
    }
    var qGrouping = input.qGrouping;
    if (qGrouping != null) {
      model['qGrouping'] = qGrouping;
    }
    var qSortCriterias = input.qSortCriterias;
    if (qSortCriterias != null) {
      var qSortCriteriasTemp0 = [];
      for (var qSortCriteriasValue0 in qSortCriterias) {
        qSortCriteriasTemp0
            .add(_nxSortCriteriaEncoder.convert(qSortCriteriasValue0));
      }
      model['qSortCriterias'] = qSortCriteriasTemp0;
    }
    var qNumberPresentations = input.qNumberPresentations;
    if (qNumberPresentations != null) {
      var qNumberPresentationsTemp0 = [];
      for (var qNumberPresentationsValue0 in qNumberPresentations) {
        qNumberPresentationsTemp0
            .add(_nxFieldAttributesEncoder.convert(qNumberPresentationsValue0));
      }
      model['qNumberPresentations'] = qNumberPresentationsTemp0;
    }
    var qReverseSort = input.qReverseSort;
    if (qReverseSort != null) {
      model['qReverseSort'] = qReverseSort;
    }
    var qAttributeExpressions = input.qAttributeExpressions;
    if (qAttributeExpressions != null) {
      var qAttributeExpressionsTemp0 = [];
      for (var qAttributeExpressionsValue0 in qAttributeExpressions) {
        qAttributeExpressionsTemp0
            .add(_nxAttrExprDefEncoder.convert(qAttributeExpressionsValue0));
      }
      model['qAttributeExpressions'] = qAttributeExpressionsTemp0;
    }
    var qActiveField = input.qActiveField;
    if (qActiveField != null) {
      model['qActiveField'] = qActiveField;
    }

    return model;
  }
}
