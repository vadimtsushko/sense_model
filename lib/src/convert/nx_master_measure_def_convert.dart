// Generated by Dogma Dart. DO NOT MODIFY!

library sense_model.src.convert.nx_master_measure_def_convert;

//---------------------------------------------------------------------
// Standard libraries
//---------------------------------------------------------------------

import 'dart:convert';

//---------------------------------------------------------------------
// Imports
//---------------------------------------------------------------------

import 'package:dogma_convert/convert.dart';
import 'package:sense_model/models.dart';
import 'nx_measure_series_convert.dart';

//---------------------------------------------------------------------
// Library contents
//---------------------------------------------------------------------

/// A [ModelDecoder] for [NxMasterMeasureDef].
class NxMasterMeasureDefDecoder extends Converter<Map, NxMasterMeasureDef>
    implements ModelDecoder<NxMasterMeasureDef> {
  final Converter<Map, NxMeasureSeries> _nxMeasureSeriesDecoder;
  NxMasterMeasureDefDecoder()
      : _nxMeasureSeriesDecoder = new NxMeasureSeriesDecoder();
  NxMasterMeasureDefDecoder.using(this._nxMeasureSeriesDecoder);
  @override
  NxMasterMeasureDef create() => new NxMasterMeasureDef();
  @override
  NxMasterMeasureDef convert(Map input, [NxMasterMeasureDef model]) {
    model ??= create();

    model.qLabel = input['qLabel'];
    model.qDescription = input['qDescription'];
    model.qDef = input['qDef'];
    model.qRelative = input['qRelative'];
    model.qBrutalSum = input['qBrutalSum'];
    model.qAggrFunc = input['qAggrFunc'];
    model.qAccumulate = input['qAccumulate'];
    model.qReverseSort = input['qReverseSort'];
    model.qActiveExpression = input['qActiveExpression'];
    model.qExpressions = input['qExpressions'];
    var series = input['series'];
    if (series != null) {
      model.series = _nxMeasureSeriesDecoder.convert(series);
    }
    model.qTags = input['qTags'];
    return model;
  }
}

/// A [ModelEncoder] for [NxMasterMeasureDef].
class NxMasterMeasureDefEncoder extends Converter<NxMasterMeasureDef, Map>
    implements ModelEncoder<NxMasterMeasureDef> {
  final Converter<NxMeasureSeries, Map> _nxMeasureSeriesEncoder;
  NxMasterMeasureDefEncoder()
      : _nxMeasureSeriesEncoder = new NxMeasureSeriesEncoder();
  NxMasterMeasureDefEncoder.using(this._nxMeasureSeriesEncoder);
  @override
  Map convert(NxMasterMeasureDef input) {
    var model = {};

    var qLabel = input.qLabel;
    if (qLabel != null) {
      model['qLabel'] = qLabel;
    }
    var qDescription = input.qDescription;
    if (qDescription != null) {
      model['qDescription'] = qDescription;
    }
    model['qDef'] = input.qDef;
    var qRelative = input.qRelative;
    if (qRelative != null) {
      model['qRelative'] = qRelative;
    }
    var qBrutalSum = input.qBrutalSum;
    if (qBrutalSum != null) {
      model['qBrutalSum'] = qBrutalSum;
    }
    var qAggrFunc = input.qAggrFunc;
    if (qAggrFunc != null) {
      model['qAggrFunc'] = qAggrFunc;
    }
    var qAccumulate = input.qAccumulate;
    if (qAccumulate != null) {
      model['qAccumulate'] = qAccumulate;
    }
    var qReverseSort = input.qReverseSort;
    if (qReverseSort != null) {
      model['qReverseSort'] = qReverseSort;
    }
    var qActiveExpression = input.qActiveExpression;
    if (qActiveExpression != null) {
      model['qActiveExpression'] = qActiveExpression;
    }
    var qExpressions = input.qExpressions;
    if (qExpressions != null) {
      model['qExpressions'] = qExpressions;
    }
    var series = input.series;
    if (series != null) {
      model['series'] = _nxMeasureSeriesEncoder.convert(series);
    }
    var qTags = input.qTags;
    if (qTags != null) {
      model['qTags'] = qTags;
    }

    return model;
  }
}
